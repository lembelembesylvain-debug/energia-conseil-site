<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mod√©lisation 3D thermique - Audit √©nerg√©tique | Energia-Conseil</title>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'DM Sans', sans-serif; overflow: hidden; background: linear-gradient(135deg, #0f766e 0%, #0d9488 50%, #10b981 100%); }
    #app { display: flex; width: 100vw; height: 100vh; }
    /* Canvas 3D : 70% largeur */
    #canvas-container { flex: 0 0 70%; height: 100%; position: relative; }
    #canvas-container canvas { display: block; width: 100% !important; height: 100% !important; }
    /* Panneau lat√©ral : 30% */
    #sidebar { flex: 0 0 30%; min-width: 280px; background: white; box-shadow: -10px 0 30px rgba(0,0,0,0.1); overflow-y: auto; padding: 1.5rem; }
    #sidebar h2 { font-size: 1.25rem; margin-bottom: 1rem; color: #1f2937; }
    .data-row { display: flex; justify-between; padding: 0.5rem 0; border-bottom: 1px solid #e5e7eb; font-size: 0.9rem; }
    .data-row strong { color: #047857; }
    .color-legend { display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 1rem 0; }
    .color-item { display: flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; }
    .color-box { width: 14px; height: 14px; border-radius: 3px; }
    /* Boutons modes en haut */
    #controls { position: absolute; top: 1rem; left: 1rem; z-index: 10; display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .mode-btn { padding: 0.5rem 0.75rem; border: none; border-radius: 0.5rem; background: rgba(255,255,255,0.95); cursor: pointer; font-family: inherit; font-size: 0.8rem; font-weight: 500; box-shadow: 0 2px 8px rgba(0,0,0,0.15); transition: all 0.2s; }
    .mode-btn:hover { background: white; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .mode-btn.active { background: #0f766e; color: white; }
    /* Slider temporal */
    #slider-container { position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); z-index: 10; background: rgba(255,255,255,0.95); padding: 0.75rem 1.25rem; border-radius: 0.75rem; box-shadow: 0 4px 20px rgba(0,0,0,0.15); }
    #slider-container label { display: block; font-size: 0.8rem; color: #374151; margin-bottom: 0.25rem; }
    #temp-slider { width: 200px; }
    /* Toggle avant/apr√®s */
    #after-toggle { position: absolute; bottom: 4rem; left: 50%; transform: translateX(-50%); z-index: 10; padding: 0.5rem 1rem; border-radius: 0.5rem; border: none; background: #10b981; color: white; cursor: pointer; font-family: inherit; font-weight: 600; box-shadow: 0 2px 10px rgba(16,185,129,0.4); transition: all 0.2s; }
    #after-toggle:hover { background: #059669; transform: translateX(-50%) translateY(-2px); }
    /* Loading */
    #loading { position: fixed; inset: 0; background: rgba(15,118,110,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; transition: opacity 0.5s; }
    #loading.hidden { opacity: 0; pointer-events: none; }
    #loading-spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 1rem; }
    @keyframes spin { to { transform: rotate(360deg); } }
    /* Donut chart placeholder */
    #donut-container { width: 120px; height: 120px; margin: 1rem auto; position: relative; }
    #donut-svg { width: 100%; height: 100%; transform: rotate(-90deg); }
    .donut-segment { transition: stroke-dasharray 0.5s; }
    /* Tooltip */
    #tooltip { position: fixed; background: rgba(0,0,0,0.9); color: white; padding: 0.75rem 1rem; border-radius: 0.5rem; font-size: 0.8rem; max-width: 280px; pointer-events: none; z-index: 50; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
    #tooltip.visible { display: block; }
    @media (max-width: 768px) {
      #app { flex-direction: column; }
      #canvas-container { flex: 1; min-height: 50vh; }
      #sidebar { flex: 0 0 auto; max-height: 50vh; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div id="loading-spinner"></div>
    <p>Chargement de la mod√©lisation 3D...</p>
  </div>

  <div id="app">
    <div id="canvas-container"></div>

    <aside id="sidebar">
      <h2>üè† Maison Dupont - Lyon</h2>
      <div id="data-panel">
        <div class="data-row"><span>D√©perditions totales</span><strong id="val-deperditions">15 000 kWh/an</strong></div>
        <div class="data-row"><span>Facture annuelle</span><strong id="val-facture">4 200 ‚Ç¨/an</strong></div>
        <div class="data-row"><span>DPE actuel</span><strong id="val-dpe">F (380 kWh/m¬≤/an)</strong></div>
        <div class="data-row"><span>√âmissions CO‚ÇÇ</span><strong id="val-co2">12 tonnes/an</strong></div>
      </div>
      <h3 style="font-size:0.95rem; margin:1rem 0 0.5rem;">D√©perditions par poste</h3>
      <div id="donut-container">
        <svg id="donut-svg" viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="40" fill="none" stroke="#e5e7eb" stroke-width="12"/>
          <circle id="d-toit" class="donut-segment" cx="50" cy="50" r="40" fill="none" stroke="#dc2626" stroke-width="12" stroke-dasharray="75 189" stroke-dashoffset="0"/>
          <circle id="d-murs" class="donut-segment" cx="50" cy="50" r="40" fill="none" stroke="#fb923c" stroke-width="12" stroke-dasharray="47 189" stroke-dashoffset="-75"/>
          <circle id="d-fenetres" class="donut-segment" cx="50" cy="50" r="40" fill="none" stroke="#ef4444" stroke-width="12" stroke-dasharray="28 189" stroke-dashoffset="-122"/>
          <circle id="d-plancher" class="donut-segment" cx="50" cy="50" r="40" fill="none" stroke="#4ade80" stroke-width="12" stroke-dasharray="19 189" stroke-dashoffset="-150"/>
        </svg>
      </div>
      <p style="font-size:0.75rem; color:#6b7280; margin-bottom:0.5rem;">Toit 30% ‚Ä¢ Murs 25% ‚Ä¢ Fen√™tres 15% ‚Ä¢ Plancher 10%</p>
      <h3 style="font-size:0.95rem; margin:1rem 0 0.5rem;">L√©gende thermique</h3>
      <div class="color-legend">
        <div class="color-item"><span class="color-box" style="background:#dc2626"></span>Critique &gt;25%</div>
        <div class="color-item"><span class="color-box" style="background:#ef4444"></span>Urgent 15-25%</div>
        <div class="color-item"><span class="color-box" style="background:#fb923c"></span>Important 10-15%</div>
        <div class="color-item"><span class="color-box" style="background:#fbbf24"></span>√Ä surveiller 5-10%</div>
        <div class="color-item"><span class="color-box" style="background:#4ade80"></span>Correct &lt;5%</div>
      </div>
    </aside>
  </div>

  <div id="controls">
    <button class="mode-btn active" data-mode="thermique">üå°Ô∏è Vue Thermique</button>
    <button class="mode-btn" data-mode="realiste">üè† Vue R√©aliste</button>
    <button class="mode-btn" data-mode="ponts">üî¥ Ponts Thermiques</button>
    <button class="mode-btn" data-mode="apres">‚úÖ Apr√®s Travaux</button>
    <label style="display:flex;align-items:center;gap:0.5rem;margin-left:0.5rem;">
      <input type="checkbox" id="auto-rotate" /> Auto-rotation
    </label>
  </div>

  <div id="slider-container">
    <label id="temp-label">Hiver -10¬∞C ‚Äî D√©perditions maximales</label>
    <input type="range" id="temp-slider" min="0" max="100" value="0" />
  </div>

  <button id="after-toggle">Voir apr√®s travaux</button>

  <div id="tooltip"></div>

  <script type="module">
    /**
     * Mod√©lisation 3D thermique interactive - Audit √©nerg√©tique Energia-Conseil
     * Visualisation des d√©perditions thermiques par zone (toit, murs, fen√™tres, plancher)
     */
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ========== CONSTANTES - Dimensions maison (m) ==========
    const DIM = { w: 10, d: 15, h: 6, roofAngle: 30 * Math.PI / 180 };
    const COULEURS = {
      thermique: { critique: 0xdc2626, urgent: 0xef4444, important: 0xfb923c, surveiller: 0xfbbf24, correct: 0x4ade80, excellent: 0x22c55e },
      realiste: { mur: 0xe8e0d5, toit: 0x8b7355, fenetre: 0x87ceeb, plancher: 0xa0a0a0, cheminee: 0x4a4a4a }
    };

    // ========== VARIABLES GLOBALES ==========
    let scene, camera, renderer, controls;
    let houseGroup, particles, particleGeometry, particleMaterial;
    let meshes = {}; // pour hover
    let modeActuel = 'thermique';
    let vueApres = false;
    let tempFactor = 1; // 0=hiver, 0.5=mi-saison, 1=√©t√©
    let materielsThermiques = {};

    // ========== INIT SC√àNE ==========
    function init() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d9488);
      scene.fog = new THREE.Fog(0x0d9488, 30, 80);

      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(25, 15, 25);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      // Lumi√®res
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const sun = new THREE.DirectionalLight(0xffffff, 0.8);
      sun.position.set(20, 30, 20);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048;
      sun.shadow.mapSize.height = 2048;
      scene.add(sun);

      // Sol (plan de r√©f√©rence)
      const solGeo = new THREE.PlaneGeometry(80, 80);
      const solMat = new THREE.MeshStandardMaterial({ color: 0x0f766e, transparent: true, opacity: 0.3 });
      const sol = new THREE.Mesh(solGeo, solMat);
      sol.rotation.x = -Math.PI / 2;
      sol.receiveShadow = true;
      scene.add(sol);

      houseGroup = new THREE.Group();
      scene.add(houseGroup);

      // 1. FONDATIONS / PLANCHER BAS (10√ó15m, h=0.3m) ‚Äî VERT
      const fondGeo = new THREE.BoxGeometry(DIM.w, 0.3, DIM.d);
      const fondMat = new THREE.MeshStandardMaterial({ color: 0x4ade80, metalness: 0.1, roughness: 0.8 });
      const fondations = new THREE.Mesh(fondGeo, fondMat);
      fondations.position.y = 0.15;
      fondations.castShadow = true;
      fondations.receiveShadow = true;
      fondations.userData = { nom: 'Plancher bas', perte: 10, kwh: 1500, etat: 'Isol√© R=3', reco: 'R=5 recommand√©' };
      houseGroup.add(fondations);
      meshes.plancher = fondations;
      materielsThermiques.plancher = fondMat;

      // 2. MURS (4 fa√ßades) ‚Äî ORANGE
      const murEp = 0.3;
      const mursConfig = [
        { pos: [0, 3.15, -DIM.d/2 - murEp/2], scale: [DIM.w + murEp*2, DIM.h, murEp], tag: 'sud' },
        { pos: [0, 3.15, DIM.d/2 + murEp/2], scale: [DIM.w + murEp*2, DIM.h, murEp], tag: 'nord' },
        { pos: [-DIM.w/2 - murEp/2, 3.15, 0], scale: [murEp, DIM.h, DIM.d + murEp*2], tag: 'ouest' },
        { pos: [DIM.w/2 + murEp/2, 3.15, 0], scale: [murEp, DIM.h, DIM.d + murEp*2], tag: 'est' }
      ];
      mursConfig.forEach(c => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshStandardMaterial({ color: 0xfb923c, metalness: 0.1, roughness: 0.85 });
        const mur = new THREE.Mesh(geo, mat);
        mur.scale.set(...c.scale);
        mur.position.set(...c.pos);
        mur.castShadow = true;
        mur.receiveShadow = true;
        mur.userData = { nom: `Mur ${c.tag}`, perte: 25, kwh: 3750, etat: 'Non isol√© R=0.5', reco: 'ITE R=7 recommand√©e' };
        houseGroup.add(mur);
        meshes[`mur_${c.tag}`] = mur;
      });
      materielsThermiques.murs = mursConfig.map((_, i) => houseGroup.children[i + 1].material);

      // Fen√™tres (8) ‚Äî ROUGE, semi-transparent
      const fenetresConfig = [
        { pos: [-3, 2, -DIM.d/2 - murEp/2 - 0.01], rot: [0, 0, 0], size: [1.2, 1.5] },
        { pos: [0, 2, -DIM.d/2 - murEp/2 - 0.01], rot: [0, 0, 0], size: [1.2, 1.5] },
        { pos: [3, 2, -DIM.d/2 - murEp/2 - 0.01], rot: [0, 0, 0], size: [1.2, 1.5] },
        { pos: [-2, 2, DIM.d/2 + murEp/2 + 0.01], rot: [0, Math.PI, 0], size: [1.2, 1.5] },
        { pos: [2, 2, DIM.d/2 + murEp/2 + 0.01], rot: [0, Math.PI, 0], size: [1.2, 1.5] },
        { pos: [-DIM.w/2 - murEp/2 - 0.01, 2, -2], rot: [0, Math.PI/2, 0], size: [1.2, 1.5] },
        { pos: [DIM.w/2 + murEp/2 + 0.01, 2, 2], rot: [0, -Math.PI/2, 0], size: [1.2, 1.5] },
        { pos: [-DIM.w/2 - murEp/2 - 0.01, 2.5, 3], rot: [0, Math.PI/2, 0], size: [1.2, 2] }
      ];
      fenetresConfig.forEach((c, i) => {
        const geo = new THREE.BoxGeometry(c.size[0], c.size[1], 0.05);
        const mat = new THREE.MeshPhysicalMaterial({ color: 0xef4444, transparent: true, opacity: 0.4, metalness: 0.1, roughness: 0.2 });
        const fen = new THREE.Mesh(geo, mat);
        fen.position.set(...c.pos);
        fen.rotation.set(...c.rot);
        fen.userData = { nom: i === 7 ? 'Porte-fen√™tre' : 'Fen√™tre', perte: 15, kwh: 2250, etat: 'Simple vitrage U=5.5', reco: 'Double/triple vitrage' };
        houseGroup.add(fen);
        meshes[`fenetre_${i}`] = fen;
      });
      materielsThermiques.fenetres = fenetresConfig.map((_, i) => houseGroup.children[8 + i]?.material).filter(m => m);  

      // 4. TOITURE (2 pentes 30¬∞)
      const ridgeH = (DIM.w / 2) * Math.tan(DIM.roofAngle);
      const slopeLen = (DIM.w / 2) / Math.cos(DIM.roofAngle);
      const toitGeo1 = new THREE.PlaneGeometry(slopeLen, DIM.d + 1);
      const toitGeo2 = toitGeo1.clone();
      const toitMat = new THREE.MeshStandardMaterial({ color: 0xdc2626, side: THREE.DoubleSide, metalness: 0.2, roughness: 0.7 });
      const toit1 = new THREE.Mesh(toitGeo1, toitMat);
      toit1.rotation.order = 'YXZ';
      toit1.rotation.y = Math.PI / 2;
      toit1.rotation.x = DIM.roofAngle;
      toit1.position.set(-DIM.w / 4, DIM.h + ridgeH / 2, 0);
      toit1.castShadow = true;
      toit1.receiveShadow = true;
      toit1.userData = { nom: 'Combles / Toiture', perte: 30, kwh: 4500, etat: 'Non isol√© R=0.5', reco: 'Isolation R=7 √† R=10' };
      houseGroup.add(toit1);
      const toit2 = new THREE.Mesh(toitGeo2, toitMat.clone());
      toit2.rotation.order = 'YXZ';
      toit2.rotation.y = -Math.PI / 2;
      toit2.rotation.x = DIM.roofAngle;
      toit2.position.set(DIM.w / 4, DIM.h + ridgeH / 2, 0);
      toit2.castShadow = true;
      toit2.receiveShadow = true;
      toit2.userData = toit1.userData;
      houseGroup.add(toit2);
      meshes.toit1 = toit1;
      meshes.toit2 = toit2;
      materielsThermiques.toit = toitMat;

      // 5. CHEMIN√âE
      const chemGeo = new THREE.BoxGeometry(0.8, 1.5, 0.8);
      const chemMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a });
      const cheminee = new THREE.Mesh(chemGeo, chemMat);
      cheminee.position.set(0, DIM.h + ridgeH + 0.75, 0);
      cheminee.castShadow = true;
      houseGroup.add(cheminee);

      // Ponts thermiques (petits cubes aux jonctions)
      const pontMat = new THREE.MeshStandardMaterial({ color: 0x991b1b });
      [[-DIM.w/2, 0.2, -DIM.d/2], [DIM.w/2, 0.2, -DIM.d/2], [-DIM.w/2, 0.2, DIM.d/2], [DIM.w/2, 0.2, DIM.d/2],
       [-DIM.w/2, DIM.h, -DIM.d/2], [DIM.w/2, DIM.h, -DIM.d/2], [-DIM.w/2, DIM.h, DIM.d/2], [DIM.w/2, DIM.h, DIM.d/2]].forEach(([x, y, z], i) => {
        const p = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), pontMat);
        p.position.set(x, y, z);
        p.userData = { nom: 'Pont thermique', perte: 5, kwh: 750, etat: 'Jonction non trait√©e', reco: 'Rupteur de pont thermique' };
        houseGroup.add(p);
        meshes[`pont_${i}`] = p;
      });

      // Particules chaleur (s'√©chappent du toit)
      const particleCount = 400;
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * DIM.w;
        positions[i * 3 + 1] = DIM.h + Math.random() * 3;
        positions[i * 3 + 2] = (Math.random() - 0.5) * DIM.d;
      }
      particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleMaterial = new THREE.PointsMaterial({ color: 0xff4444, size: 0.15, transparent: true, opacity: 0.6 });
      particles = new THREE.Points(particleGeometry, particleMaterial);
      houseGroup.add(particles);

      // OrbitControls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 10;
      controls.maxDistance = 60;

      // Raycaster pour hover
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const tooltip = document.getElementById('tooltip');

      function onMouseMove(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      }
      container.addEventListener('mousemove', onMouseMove);

      function updateTooltip() {
        raycaster.setFromCamera(mouse, camera);
        const objs = [];
        houseGroup.traverse(c => { if (c.isMesh && c.userData.nom) objs.push(c); });
        const hits = raycaster.intersectObjects(objs, true);
        if (hits.length > 0 && hits[0].object.userData.nom) {
          const u = hits[0].object.userData;
          tooltip.innerHTML = `<strong>${u.nom}</strong><br/>${u.perte}% de pertes ‚Ä¢ ${u.kwh} kWh/an<br/>${u.etat}<br/><em>${u.reco}</em>`;
          tooltip.classList.add('visible');
          const rect = renderer.domElement.getBoundingClientRect();
          tooltip.style.left = (rect.left + (mouse.x * 0.5 + 0.5) * rect.width) - 120 + 'px';
          tooltip.style.top = (rect.top + (-mouse.y * 0.5 + 0.5) * rect.height) - 100 + 'px';
        } else {
          tooltip.classList.remove('visible');
        }
      }

      // UI
      function updateDataPanel(apres) {
        if (apres) {
          document.getElementById('val-deperditions').textContent = '3 000 kWh/an';
          document.getElementById('val-facture').textContent = '1 000 ‚Ç¨/an';
          document.getElementById('val-dpe').textContent = 'B (80 kWh/m¬≤/an)';
          document.getElementById('val-co2').textContent = '2 tonnes/an';
        } else {
          document.getElementById('val-deperditions').textContent = '15 000 kWh/an';
          document.getElementById('val-facture').textContent = '4 200 ‚Ç¨/an';
          document.getElementById('val-dpe').textContent = 'F (380 kWh/m¬≤/an)';
          document.getElementById('val-co2').textContent = '12 tonnes/an';
        }
      }
      document.querySelectorAll('.mode-btn[data-mode]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.mode-btn[data-mode]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          modeActuel = btn.dataset.mode;
          if (modeActuel === 'apres') { vueApres = true; updateDataPanel(true); }
          else { vueApres = false; updateDataPanel(false); }
          document.getElementById('after-toggle').textContent = vueApres ? 'Voir avant travaux' : 'Voir apr√®s travaux';
          appliquerMode();
        });
      });

      document.getElementById('auto-rotate').addEventListener('change', e => { controls.autoRotate = e.target.checked; });

      document.getElementById('temp-slider').addEventListener('input', e => {
        tempFactor = e.target.value / 100;
        const labels = ['Hiver -10¬∞C ‚Äî D√©perditions maximales', 'Mi-saison 15¬∞C', '√ât√© 30¬∞C ‚Äî Besoin fra√Æcheur'];
        document.getElementById('temp-label').textContent = labels[Math.round(tempFactor * 2)];
        appliquerMode();
      });

      document.getElementById('after-toggle').addEventListener('click', () => {
        vueApres = !vueApres;
        document.getElementById('after-toggle').textContent = vueApres ? 'Voir avant travaux' : 'Voir apr√®s travaux';
        updateDataPanel(vueApres);
        if (vueApres) {
          transitionVersApres();
          document.querySelector('.mode-btn[data-mode="apres"]')?.classList.add('active');
          document.querySelectorAll('.mode-btn[data-mode]').forEach(b => { if (b.dataset.mode !== 'apres') b.classList.remove('active'); });
          modeActuel = 'apres';
        } else {
          document.querySelector('.mode-btn[data-mode="thermique"]')?.classList.add('active');
          document.querySelector('.mode-btn[data-mode="apres"]')?.classList.remove('active');
          modeActuel = 'thermique';
          appliquerMode();
        }
      });

      function appliquerMode() {
        const vert = new THREE.Color(0x22c55e);
        const rouge = new THREE.Color(0xdc2626);
        const orange = new THREE.Color(0xfb923c);
        houseGroup.traverse(c => {
          if (!c.isMesh || !c.material) return;
          if (vueApres) {
            c.material.color?.copy(vert);
            if (c.material.opacity !== undefined) c.material.opacity = 0.5;
          } else if (modeActuel === 'thermique') {
            if (c.userData.perte) {
              const t = 1 - tempFactor * 0.5;
              if (c.userData.nom?.includes('Plancher')) c.material.color?.setHex(0x4ade80);
              else if (c.userData.nom?.includes('Combles') || c.userData.nom?.includes('Toiture')) c.material.color?.setHex(0xdc2626);
              else if (c.userData.nom?.includes('Fen√™tre') || c.userData.nom?.includes('Porte')) c.material.color?.setHex(0xef4444);
              else if (c.userData.nom?.includes('Mur')) c.material.color?.setHex(0xfb923c);
              else if (c.userData.nom?.includes('Pont')) c.material.color?.setHex(0x991b1b);
            }
          } else if (modeActuel === 'realiste') {
            if (c.userData.nom?.includes('Plancher')) c.material.color?.setHex(0xa0a0a0);
            else if (c.userData.nom?.includes('Combles') || c.userData.nom?.includes('Toiture')) c.material.color?.setHex(0x8b7355);
            else if (c.userData.nom?.includes('Fen√™tre') || c.userData.nom?.includes('Porte')) { c.material.color?.setHex(0x87ceeb); c.material.opacity = 0.5; }
            else if (c.userData.nom?.includes('Mur')) c.material.color?.setHex(0xe8e0d5);
            else if (c.userData.nom?.includes('Pont')) c.material.color?.setHex(0x991b1b);
          } else if (modeActuel === 'ponts') {
            if (c.userData.nom?.includes('Pont')) c.material.color?.setHex(0xff0000);
            else c.material.color?.setHex(0xcccccc);
          }
        });
        particles.visible = !vueApres && modeActuel === 'thermique';
        particleMaterial.opacity = 0.4 + (1 - tempFactor) * 0.4;
      }

      const vertCible = new THREE.Color(0x22c55e);
      function transitionVersApres() {
        const start = Date.now();
        const d = 3000;
        function step() {
          const elapsed = Date.now() - start;
          const t = Math.min(elapsed / d, 1);
          const alpha = 0.02; // ~2% vers vert par frame, ~3s pour arriver
          houseGroup.traverse(c => {
            if (!c.isMesh || !c.material?.color) return;
            c.material.color.lerp(vertCible, alpha);
            if (c.material.opacity !== undefined) c.material.opacity = 0.5 + 0.4 * Math.min(t * 2, 1);
          });
          if (t < 1) requestAnimationFrame(step);
        }
        step();
      }

      // Resize
      window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });

      // Boucle d'animation
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        if (particles.visible) {
          const pos = particleGeometry.attributes.position.array;
          for (let i = 0; i < pos.length; i += 3) {
            pos[i + 1] += 0.02 + Math.random() * 0.02;
            if (pos[i + 1] > DIM.h + 6) pos[i + 1] = DIM.h;
          }
          particleGeometry.attributes.position.needsUpdate = true;
        }
        updateTooltip();
        renderer.render(scene, camera);
        controls.update();
      }
      animate();

      document.getElementById('loading').classList.add('hidden');
    }

    init();
  </script>
</body>
</html>
